\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md14}{}\doxysection{Unityバージョン}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md14}
Unity2021.\+3以降

\DoxyHorRuler{0}
\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md16}{}\doxysection{使用方法}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md16}
\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md17}{}\doxysubsection{編集ウィンドウの起動}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md17}

\begin{DoxyItemize}
\item Unity\+Editorメニュー → Be\+Xide -\/\texorpdfstring{$>$}{>} Scenario\+Builder -\/\texorpdfstring{$>$}{>} Edit
\end{DoxyItemize}

起動するとウィンドウが開きます。 プロジェクト内にシナリオファイルが存在しない場合、中央に「新規作成」のボタンが表示されます。 

「新規作成」のボタンを押し、シナリオファイルを保存する場所を決めて作成します。 

※1.\+プロジェクト内に1つでもシナリオファイルが存在する場合は、ウィンドウを開いたときに一覧が表示されます。 ~\newline
 一覧内から編集したいシナリオファイルをダブルクリック、もしくは「\+OPEN」ボタンで編集を始めることが出来ます。 ~\newline
 

※2.\+作成したシナリオファイルの\+Inspectorから「\+Open\+Editor」ボタンを押すことで編集ウィンドウを開くことも出来ます。 \hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md18}{}\doxysubsection{シナリオファイルの編集方法}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md18}

\begin{DoxyEnumerate}
\item 左側のエリアに並んでいるコマンドを中央の白枠内のエリアにドラッグ＆ドロップします。
\item 編集したいコマンドを左クリックすることで右側のエリア内でコマンドに対応する各パラメータを編集することが出来ます。 
\end{DoxyEnumerate}\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md19}{}\doxysubsection{シナリオファイルの再生方法}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md19}
基本的には\+Unityで実装されている「\+Timeline」に近いような作りになっています。


\begin{DoxyEnumerate}
\item 任意の\+Game\+Objectに「\+Command\+Engine\+Director」というコンポーネントを貼ります。
\item 「\+Command\+Engine\+Director」を付けた\+Game\+Objectの子に1つ以上\+Game\+Objectを作成し、その\+Game\+Objectに「\+Base\+Command\+Runner」を継承したコンポーネントを貼ります。
\item 「\+Command\+Engine\+Director」の\+Inspectorを見ると「\+Scenario\+Asset」というプロパティがあるので、そこに再生したいシナリオファイルを指定します。
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item もう1つ「\+Play\+On\+Awake」というプロパティがありますが、これは\+Awake時に再生をするかどうかのチェックになりますので、必要に応じて使い分けてください。
\end{DoxyItemize}\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md20}{}\doxysubsubsection{(別解)プログラム側からシナリオファイルを再生する。}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md20}
例えば\+Addressablesからシナリオファイルを読み込んで\+Command\+Engine\+Directorに渡し再生するという事も可能です。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{namespace_bx_uni_1_1_scenario_builder}{BxUni.ScenarioBuilder}};}
\DoxyCodeLine{}
\DoxyCodeLine{[SerializeField] \mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_command_engine_director}{CommandEngineDirector}} m\_director;}
\DoxyCodeLine{}
\DoxyCodeLine{var scenarioAsset = await Addressables.LoadAsync<ScenarioAsset>(key);}
\DoxyCodeLine{m\_director.\mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_command_engine_director_aaef23e947ad5181f6650f70d81173d83}{Initialize}}(scenarioAsset);}
\DoxyCodeLine{m\_director.\mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_command_engine_director_a6e4c3e28c3c9abaf8903e40c17aba41f}{Play}}();}

\end{DoxyCode}


\DoxyHorRuler{0}
\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md22}{}\doxysection{プログラム}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md22}
\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md23}{}\doxysubsection{新規でコマンドを作成する方法}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md23}
以下の手順でオリジナルのコマンドを作成することが出来ます。 ここではコマンドのパラメータとして指定した文字列を\+Debug.\+Logで表示するサンプルをもとに説明します。


\begin{DoxyEnumerate}
\item Base\+Commandクラスを継承したクラスを作成する 
\begin{DoxyCode}{0}
\DoxyCodeLine{using UnityEngine;}
\DoxyCodeLine{using BxUni.ScenarioBuilder;          //usingで指定}
\DoxyCodeLine{}
\DoxyCodeLine{[System.Serializable]                 //System.SerializableAttributeを付ける}
\DoxyCodeLine{public class LogCommand : BaseCommand //BaseCommandを継承する}
\DoxyCodeLine{\{}
\DoxyCodeLine{    [Header("{}Logで表示する文字列"{})]}
\DoxyCodeLine{    [SerializeField] string m\_text;   //コマンドのパラメータを宣言}
\DoxyCodeLine{}
\DoxyCodeLine{    /// <summary>}
\DoxyCodeLine{    /// Logで表示する文字列}
\DoxyCodeLine{    /// </summary>}
\DoxyCodeLine{    public string Text => m\_text;     //CommandRunner側で読み取れるようにgetterプロパティを追加}
\DoxyCodeLine{\}}

\end{DoxyCode}

\item 作成したコマンドを処理するために\+Base\+Command\+Runnerを継承したクラスを用意する 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{namespace_bx_uni_1_1_scenario_builder}{BxUni.ScenarioBuilder}};                      \textcolor{comment}{//usingで指定}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public} \textcolor{keyword}{class }LogCommandRunner : \mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_base_command_runner}{BaseCommandRunner}} \textcolor{comment}{//BaseCommandRunnerを継承する}}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{    [CommandRunner(typeof(LogCommand))]           \textcolor{comment}{//CommandRunnerAttributeを付けたメソッドを用意する}}
\DoxyCodeLine{                                                  \textcolor{comment}{//CommandRunnerAttributeの引数に対応するコマンドのTypeを指定する}}
\DoxyCodeLine{    \textcolor{keyword}{public} \textcolor{keywordtype}{void} DumpLog(LogCommand cmd)           \textcolor{comment}{//メソッドの名前は任意で、引数に対応するコマンドを指定する}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        Debug.Log(cmd.Text);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{\}}

\end{DoxyCode}

\item Projectウィンドウ内の\+Editorフォルダ以下で右クリックをし、\+Create \texorpdfstring{$>$}{>} Be\+Xide \texorpdfstring{$>$}{>} Scenario\+Builder \texorpdfstring{$>$}{>} Command\+Regist\+Config をクリックして\+Command\+Regist\+Config.\+assetを作成します。
\end{DoxyEnumerate}

※基本プロジェクトに1つあればいいので、2回目以降はこの手順はスキップ可




\begin{DoxyEnumerate}
\item Command\+Regist\+Config.\+assetに情報を追加していきます。
\end{DoxyEnumerate}
\begin{DoxyItemize}
\item +ボタンを押してグループを追加します。
\begin{DoxyItemize}
\item 「\+Group Name」に任意のグループ名を入力します。
\item 「\+Enabled」にチェックを入れます。
\item 「\+Color」に任意の色を指定します。
\item 「\+Command Drawers」のリストで＋ボタンを押します。
\begin{DoxyItemize}
\item 「\+View Name」にコマンドを表す名前を入力します。
\item （対応しなくても可）「\+Icon」に任意の\+Textureを参照させると、編集ウィンドウ内のアイコンが変わります。
\item 「\+Script」でコマンドの\+Mono\+Scriptを指定します。（今回だと\+Log\+Command.\+cs）
\item 「\+Tooltip」にコマンドの説明を入力します。
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}



以上の対応で完了です。 ~\newline
 \hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md24}{}\doxysubsection{特殊なコマンドについて}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md24}

\begin{DoxyEnumerate}
\item 待機コマンド
\end{DoxyEnumerate}

指定秒待機したり、何かの動作を待機したりなど非同期な処理を行う場合は\+Command\+Runnerのメソッドの返値を{\ttfamily System.\+Threading.\+Tasks.\+Task}、もしくは{\ttfamily Cysharp.\+Threading.\+Tasks.\+Uni\+Task}にすれば\+OKです。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// System.Threading.Tasks.Task の例}}
\DoxyCodeLine{\textcolor{keyword}{using }System.Threading;}
\DoxyCodeLine{\textcolor{keyword}{using }System.Threading.Tasks;}
\DoxyCodeLine{}
\DoxyCodeLine{[CommandRunner(typeof(ExampleTaskCommand))]}
\DoxyCodeLine{\textcolor{keyword}{public} async Task WaitDelayTask(ExampleTaskCommand cmd, CancellationToken ct = \textcolor{keywordflow}{default})}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{comment}{//指定秒待機したら次のコマンドが実行されます。}}
\DoxyCodeLine{    await Task.Delay(System.TimeSpan.FromSeconds(cmd.Sec));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Cysharp.Threading.Tasks.UniTask の例}}
\DoxyCodeLine{\textcolor{keyword}{using }System.Threading;}
\DoxyCodeLine{\textcolor{keyword}{using }Cysharp.Threading.Tasks;}
\DoxyCodeLine{}
\DoxyCodeLine{[CommandRunner(typeof(ExampleTaskCommand))]}
\DoxyCodeLine{\textcolor{keyword}{public} async UniTask WaitDelayTask(ExampleTaskCommand cmd, CancellationToken ct = \textcolor{keywordflow}{default})}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{comment}{//指定秒待機したら次のコマンドが実行されます。}}
\DoxyCodeLine{    await UniTask.Delay(System.TimeSpan.FromSeconds(cmd.Sec));}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyEnumerate}
\item ジャンプコマンド ~\newline
 パッケージを入れた時から使用出来る「ラベルコマンド」と「ジャンプコマンド」があります。 ~\newline
 例えば以下の画像のように設定すると1個目のジャンプコマンドで3個目のラベルコマンドにジャンプするので 2個目の\+Log\+Commandは無視されます。 ~\newline
 
\end{DoxyEnumerate}

この仕組みを利用し、自作のジャンプコマンドを用意することが出来ます。 ~\newline
 ここではコマンド側で指定した複数のラベルからランダムで1つ選択し、そこへジャンプするサンプルを書いてみます。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Command}}
\DoxyCodeLine{\textcolor{keyword}{using }UnityEngine;}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{namespace_bx_uni_1_1_scenario_builder}{BxUni.ScenarioBuilder}};}
\DoxyCodeLine{}
\DoxyCodeLine{[System.Serializable]}
\DoxyCodeLine{\textcolor{keyword}{public} \textcolor{keyword}{class }RandomJumpCommand : \mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_base_command}{BaseCommand}}}
\DoxyCodeLine{    , \mbox{\hyperlink{interface_bx_uni_1_1_scenario_builder_1_1_i_jump_command}{IJumpCommand}}                                  \textcolor{comment}{// IJumpCommand のインターフェースを実装する}}
\DoxyCodeLine{\{}
\DoxyCodeLine{    [Header(\textcolor{stringliteral}{"{}ジャンプ先のラベル"{}})]}
\DoxyCodeLine{    [SerializeField, \mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_label_command}{LabelCommand}}]}
\DoxyCodeLine{    \textcolor{keywordtype}{string}[] m\_targetLabels = \textcolor{keyword}{new} \textcolor{keywordtype}{string}[0];}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{public} \textcolor{keywordtype}{string}[] TargetLabels => m\_targetLabels;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// CommandRunner}}
\DoxyCodeLine{\textcolor{keyword}{using }UnityEngine;}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{namespace_bx_uni_1_1_scenario_builder}{BxUni.ScenarioBuilder}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public} \textcolor{keyword}{class }RandomJumpCommandRunner : \mbox{\hyperlink{class_bx_uni_1_1_scenario_builder_1_1_base_command_runner}{BaseCommandRunner}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{    [CommandRunner(typeof(RandomJumpCommand))]}
\DoxyCodeLine{    \textcolor{keyword}{public} \textcolor{keywordtype}{string} RandomJump(RandomJumpCommand cmd)           \textcolor{comment}{// 返値をstringにする}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordtype}{int} index = Random.Range(0, cmd.TargetLabels.Length);}
\DoxyCodeLine{        \textcolor{keywordtype}{string} label = cmd.TargetLabels[index];}
\DoxyCodeLine{        \textcolor{keywordflow}{return} label;　　　　　　　　　　　　　　　　　　　　　　\textcolor{comment}{// ジャンプ先のラベル名を返す}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{    // 返値を「Task<string>」、または「UniTask<string>」にすることで}}
\DoxyCodeLine{\textcolor{comment}{    // 非同期の実装も可能。}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    [CommandRunner(typeof(RandomJumpCommand))]}}
\DoxyCodeLine{\textcolor{comment}{    public async UniTask<string> RandomJump(}}
\DoxyCodeLine{\textcolor{comment}{        RandomJumpCommand cmd, CancellationToken = default}}
\DoxyCodeLine{\textcolor{comment}{    )}}
\DoxyCodeLine{\textcolor{comment}{    \{}}
\DoxyCodeLine{\textcolor{comment}{        // 以下の場合、3秒待ってからジャンプとなる。}}
\DoxyCodeLine{\textcolor{comment}{        await UniTask.Delay(System.TimeSpan.FromSeconds(3));}}
\DoxyCodeLine{\textcolor{comment}{        int index = Random.Range(0, cmd.TargetLabels.Length);}}
\DoxyCodeLine{\textcolor{comment}{        string label = cmd.TargetLabels[index];}}
\DoxyCodeLine{\textcolor{comment}{        return label;}}
\DoxyCodeLine{\textcolor{comment}{    \}}}
\DoxyCodeLine{\textcolor{comment}{    //*/}}
\DoxyCodeLine{\}}

\end{DoxyCode}


\DoxyHorRuler{0}
\hypertarget{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md26}{}\doxysection{その他}\label{md__c__home_murakami__b_x_tools__bx_uni__scenario_builder__packages__bx_uni__scenario_builder__documents__index_autotoc_md26}
./\+Editor\%20\+Extensions.\+md \char`\"{}コマンドの\+Editor拡張について\char`\"{}

./\+External\%20\+Uni\+Rx.\+md \char`\"{}\+Uni\+Rxをプロジェクトに含める\char`\"{}

./\+External\%20\+Uni\+Task.\+md \char`\"{}\+Uni\+Taskをプロジェクトに含める\char`\"{}

\href{./Reference/html/index.html}{\texttt{ コードリファレンス}} 